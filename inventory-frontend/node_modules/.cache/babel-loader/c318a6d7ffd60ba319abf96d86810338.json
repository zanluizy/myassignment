{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @fileOverview Curve\n */\nimport React from 'react';\nimport { line as shapeLine, area as shapeArea, curveBasisClosed, curveBasisOpen, curveBasis, curveBumpX, curveBumpY, curveLinearClosed, curveLinear, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore } from 'victory-vendor/d3-shape';\nimport upperFirst from 'lodash/upperFirst';\nimport isFunction from 'lodash/isFunction';\nimport clsx from 'clsx';\nimport { adaptEventHandlers } from '../util/types';\nimport { filterProps } from '../util/ReactUtils';\nimport { isNumber } from '../util/DataUtils';\nvar CURVE_FACTORIES = {\n  curveBasisClosed: curveBasisClosed,\n  curveBasisOpen: curveBasisOpen,\n  curveBasis: curveBasis,\n  curveBumpX: curveBumpX,\n  curveBumpY: curveBumpY,\n  curveLinearClosed: curveLinearClosed,\n  curveLinear: curveLinear,\n  curveMonotoneX: curveMonotoneX,\n  curveMonotoneY: curveMonotoneY,\n  curveNatural: curveNatural,\n  curveStep: curveStep,\n  curveStepAfter: curveStepAfter,\n  curveStepBefore: curveStepBefore\n};\nvar defined = function defined(p) {\n  return p.x === +p.x && p.y === +p.y;\n};\nvar getX = function getX(p) {\n  return p.x;\n};\nvar getY = function getY(p) {\n  return p.y;\n};\nvar getCurveFactory = function getCurveFactory(type, layout) {\n  if (isFunction(type)) {\n    return type;\n  }\n  var name = \"curve\".concat(upperFirst(type));\n  if ((name === 'curveMonotone' || name === 'curveBump') && layout) {\n    return CURVE_FACTORIES[\"\".concat(name).concat(layout === 'vertical' ? 'Y' : 'X')];\n  }\n  return CURVE_FACTORIES[name] || curveLinear;\n};\n/**\n * Calculate the path of curve. Returns null if points is an empty array.\n * @return path or null\n */\nexport var getPath = function getPath(_ref) {\n  var _ref$type = _ref.type,\n    type = _ref$type === void 0 ? 'linear' : _ref$type,\n    _ref$points = _ref.points,\n    points = _ref$points === void 0 ? [] : _ref$points,\n    baseLine = _ref.baseLine,\n    layout = _ref.layout,\n    _ref$connectNulls = _ref.connectNulls,\n    connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;\n  var curveFactory = getCurveFactory(type, layout);\n  var formatPoints = connectNulls ? points.filter(function (entry) {\n    return defined(entry);\n  }) : points;\n  var lineFunction;\n  if (Array.isArray(baseLine)) {\n    var formatBaseLine = connectNulls ? baseLine.filter(function (base) {\n      return defined(base);\n    }) : baseLine;\n    var areaPoints = formatPoints.map(function (entry, index) {\n      return _objectSpread(_objectSpread({}, entry), {}, {\n        base: formatBaseLine[index]\n      });\n    });\n    if (layout === 'vertical') {\n      lineFunction = shapeArea().y(getY).x1(getX).x0(function (d) {\n        return d.base.x;\n      });\n    } else {\n      lineFunction = shapeArea().x(getX).y1(getY).y0(function (d) {\n        return d.base.y;\n      });\n    }\n    lineFunction.defined(defined).curve(curveFactory);\n    return lineFunction(areaPoints);\n  }\n  if (layout === 'vertical' && isNumber(baseLine)) {\n    lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);\n  } else if (isNumber(baseLine)) {\n    lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);\n  } else {\n    lineFunction = shapeLine().x(getX).y(getY);\n  }\n  lineFunction.defined(defined).curve(curveFactory);\n  return lineFunction(formatPoints);\n};\nexport var Curve = function Curve(props) {\n  var className = props.className,\n    points = props.points,\n    path = props.path,\n    pathRef = props.pathRef;\n  if ((!points || !points.length) && !path) {\n    return null;\n  }\n  var realPath = points && points.length ? getPath(props) : path;\n  return /*#__PURE__*/React.createElement(\"path\", _extends({}, filterProps(props, false), adaptEventHandlers(props), {\n    className: clsx('recharts-curve', className),\n    d: realPath,\n    ref: pathRef\n  }));\n};","map":null,"metadata":{},"sourceType":"module"}